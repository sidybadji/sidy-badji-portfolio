<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netflix Recommendation Engine - Sidy Badji Portfolio</title>
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/style.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
</head>
<body class="bg-dark text-light">
    <div class="container py-5">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <!-- Header -->
                <div class="text-center mb-5">
                    <h1 class="display-4 text-primary mb-3">üé¨ Netflix Recommendation Engine</h1>
                    <p class="lead">Syst√®me de recommandation de contenu avec pipeline de donn√©es en temps r√©el</p>
                    <div class="d-flex justify-content-center gap-3 mb-4">
                        <span class="badge bg-primary">Python</span>
                        <span class="badge bg-warning text-dark">Apache Spark</span>
                        <span class="badge bg-info">Google Cloud Platform</span>
                        <span class="badge bg-success">BigQuery</span>
                        <span class="badge bg-danger">Pub/Sub</span>
                    </div>
                </div>

                <!-- Project Overview -->
                <div class="card bg-secondary mb-4">
                    <div class="card-body">
                        <h3 class="card-title">üìã Vue d'ensemble du projet</h3>
                        <p class="card-text">
                            Moteur de recommandation avanc√© pour Netflix utilisant des algorithmes de machine learning
                            et des pipelines de donn√©es en streaming pour personnaliser l'exp√©rience utilisateur.
                        </p>
                        <ul class="list-unstyled">
                            <li>üéØ <strong>Algorithme:</strong> Collaborative Filtering + Content-Based</li>
                            <li>‚ö° <strong>Latence:</strong> < 100ms pour les recommandations</li>
                            <li>üìä <strong>Dataset:</strong> 50M+ interactions utilisateurs</li>
                        </ul>
                    </div>
                </div>

                <!-- Architecture -->
                <div class="card bg-secondary mb-4">
                    <div class="card-body">
                        <h3 class="card-title">üèóÔ∏è Architecture du syst√®me</h3>
                        <div class="text-center mb-3">
                            <img src="../img/portfolio-2.jpg" alt="Architecture Netflix" class="img-fluid rounded">
                        </div>
                        <p>Pipeline de donn√©es en temps r√©el avec Pub/Sub, traitement Spark et stockage BigQuery.</p>
                    </div>
                </div>

                <!-- Code Section -->
                <div class="card bg-secondary mb-4">
                    <div class="card-body">
                        <h3 class="card-title">üíª Code Python - Moteur de Recommandation</h3>
                        <pre class="line-numbers"><code class="language-python">from pyspark.sql import SparkSession
from pyspark.sql.functions import *
from pyspark.ml import Pipeline
from pyspark.ml.recommendation import ALS
from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml.evaluation import RegressionEvaluator
from google.cloud import pubsub_v1
from google.cloud import bigquery
import json
import numpy as np
from datetime import datetime, timedelta

class NetflixRecommendationEngine:
    def __init__(self):
        self.spark = SparkSession.builder \
            .appName("NetflixRecommendationEngine") \
            .config("spark.sql.adaptive.enabled", "true") \
            .config("spark.sql.adaptive.skewJoin.enabled", "true") \
            .getOrCreate()
        
        self.publisher = pubsub_v1.PublisherClient()
        self.bq_client = bigquery.Client()
        self.topic_path = "projects/netflix-data-project/topics/user-interactions"
    
    def load_user_data(self, bucket_name, ratings_file, movies_file):
        """Chargement des donn√©es utilisateurs et films"""
        ratings_df = self.spark.read.option("header", "true") \
            .option("inferSchema", "true") \
            .csv(f"gs://{bucket_name}/{ratings_file}")
        
        movies_df = self.spark.read.option("header", "true") \
            .option("inferSchema", "true") \
            .csv(f"gs://{bucket_name}/{movies_file}")
        
        return ratings_df, movies_df
    
    def preprocess_data(self, ratings_df, movies_df):
        """Pr√©processing des donn√©es pour l'entra√Ænement"""
        # Indexation des utilisateurs et films
        user_indexer = StringIndexer(inputCol="userId", outputCol="userIndex")
        movie_indexer = StringIndexer(inputCol="movieId", outputCol="movieIndex")
        
        # Pipeline de pr√©processing
        preprocessing_pipeline = Pipeline(stages=[user_indexer, movie_indexer])
        model = preprocessing_pipeline.fit(ratings_df)
        processed_data = model.transform(ratings_df)
        
        # Ajout des m√©tadonn√©es des films
        enriched_data = processed_data.join(
            movies_df.select("movieId", "title", "genres"), 
            "movieId"
        )
        
        return enriched_data, model
    
    def train_collaborative_filtering(self, data):
        """Entra√Ænement du mod√®le de filtrage collaboratif ALS"""
        als = ALS(
            rank=50,
            maxIter=10,
            regParam=0.1,
            userCol="userIndex",
            itemCol="movieIndex",
            ratingCol="rating",
            coldStartStrategy="drop"
        )
        
        # Division train/test
        train_data, test_data = data.randomSplit([0.8, 0.2], seed=42)
        
        # Entra√Ænement
        als_model = als.fit(train_data)
        
        # √âvaluation
        predictions = als_model.transform(test_data)
        evaluator = RegressionEvaluator(
            metricName="rmse", 
            labelCol="rating", 
            predictionCol="prediction"
        )
        rmse = evaluator.evaluate(predictions)
        
        return als_model, rmse
    
    def content_based_filtering(self, movies_df, user_history):
        """Filtrage bas√© sur le contenu des films"""
        # Extraction des genres
        genres_exploded = movies_df.withColumn(
            "genre", 
            explode(split(col("genres"), "\\|"))
        )
        
        # Matrice de similarit√© bas√©e sur les genres
        genre_matrix = genres_exploded.groupBy("movieId") \
            .pivot("genre") \
            .agg(count("*").alias("count")) \
            .fillna(0)
        
        # Recommandations bas√©es sur l'historique utilisateur
        user_preferences = user_history.groupBy("userIndex") \
            .agg(collect_list("movieIndex").alias("watched_movies"))
        
        return genre_matrix, user_preferences
    
    def hybrid_recommendation(self, als_model, user_index, genre_matrix, user_preferences):
        """Syst√®me de recommandation hybride"""
        # Recommandations ALS
        als_recommendations = als_model.recommendForUserSubset(
            self.spark.createDataFrame([(user_index,)], ["userIndex"]), 
            20
        )
        
        # Recommandations bas√©es sur le contenu
        user_watched = user_preferences.filter(col("userIndex") == user_index)
        
        # Combinaison des recommandations avec poids
        hybrid_score = als_recommendations.withColumn(
            "hybrid_score",
            col("recommendations.movieIndex") * 0.7 + 
            col("content_score") * 0.3
        )
        
        return hybrid_score
    
    def real_time_recommendation(self, user_id, movie_id, rating):
        """Traitement en temps r√©el des interactions utilisateur"""
        # Publication de l'interaction dans Pub/Sub
        interaction_data = {
            "userId": user_id,
            "movieId": movie_id,
            "rating": rating,
            "timestamp": datetime.now().isoformat(),
            "sessionId": f"session_{user_id}_{int(datetime.now().timestamp())}"
        }
        
        message_data = json.dumps(interaction_data).encode('utf-8')
        future = self.publisher.publish(self.topic_path, message_data)
        future.result()  # Attendre la publication
        
        return interaction_data
    
    def update_model_incremental(self, new_interactions):
        """Mise √† jour incr√©mentale du mod√®le"""
        # Chargement des nouvelles interactions
        new_data = self.spark.read.json(new_interactions)
        
        # Fusion avec les donn√©es existantes
        updated_data = self.spark.table("user_interactions") \
            .union(new_data)
        
        # R√©entra√Ænement du mod√®le avec les nouvelles donn√©es
        als = ALS(
            rank=50,
            maxIter=5,  # Moins d'it√©rations pour l'incr√©mental
            regParam=0.1,
            userCol="userIndex",
            itemCol="movieIndex",
            ratingCol="rating"
        )
        
        updated_model = als.fit(updated_data)
        
        return updated_model
    
    def save_recommendations_to_bigquery(self, recommendations_df, user_id):
        """Sauvegarde des recommandations dans BigQuery"""
        table_id = f"netflix_recommendations.user_{user_id}_recommendations"
        
        recommendations_df.write \
            .format("bigquery") \
            .option("table", table_id) \
            .option("writeMethod", "direct") \
            .mode("overwrite") \
            .save()
    
    def generate_insights(self, als_model, genre_matrix):
        """G√©n√©ration d'insights sur les recommandations"""
        insights = []
        
        # Top films les plus populaires
        top_movies = als_model.itemFactors.orderBy("features", ascending=False).limit(10)
        
        # Analyse des genres populaires
        genre_popularity = genre_matrix.groupBy("genre").agg(
            sum("count").alias("total_watches")
        ).orderBy("total_watches", ascending=False)
        
        insights.append({
            "metric": "Films populaires",
            "value": top_movies.count(),
            "insight": "Top 10 des films les plus recommand√©s"
        })
        
        insights.append({
            "metric": "Genres analys√©s",
            "value": genre_popularity.count(),
            "insight": "Diversit√© des genres dans les recommandations"
        })
        
        return insights

# Fonction principale
def main():
    engine = NetflixRecommendationEngine()
    
    # Chargement des donn√©es
    ratings_df, movies_df = engine.load_user_data(
        "netflix-data-bucket", 
        "ratings.csv", 
        "movies.csv"
    )
    
    # Pr√©processing
    processed_data, preprocessing_model = engine.preprocess_data(ratings_df, movies_df)
    
    # Entra√Ænement du mod√®le
    als_model, rmse = engine.train_collaborative_filtering(processed_data)
    print(f"‚úÖ Mod√®le ALS entra√Æn√© - RMSE: {rmse:.4f}")
    
    # Filtrage bas√© sur le contenu
    genre_matrix, user_preferences = engine.content_based_filtering(
        movies_df, processed_data
    )
    
    # Exemple de recommandation pour un utilisateur
    user_id = 1
    recommendations = engine.hybrid_recommendation(
        als_model, user_id, genre_matrix, user_preferences
    )
    
    # Sauvegarde des recommandations
    engine.save_recommendations_to_bigquery(recommendations, user_id)
    
    # G√©n√©ration d'insights
    insights = engine.generate_insights(als_model, genre_matrix)
    
    print("üé¨ Moteur de recommandation Netflix op√©rationnel!")
    for insight in insights:
        print(f"üìä {insight['metric']}: {insight['value']} - {insight['insight']}")

if __name__ == "__main__":
    main()</code></pre>
                    </div>
                </div>

                <!-- ML Pipeline -->
                <div class="card bg-secondary mb-4">
                    <div class="card-body">
                        <h3 class="card-title">ü§ñ Pipeline Machine Learning</h3>
                        <pre class="line-numbers"><code class="language-yaml"># ml_pipeline.yaml
apiVersion: kubeflow.org/v1
kind: Pipeline
metadata:
  name: netflix-recommendation-pipeline
spec:
  templates:
  - name: data-preprocessing
    container:
      image: gcr.io/netflix-ml/data-preprocessing:latest
      command: ["python", "preprocess.py"]
  
  - name: model-training
    container:
      image: gcr.io/netflix-ml/model-training:latest
      command: ["python", "train_als.py"]
  
  - name: model-evaluation
    container:
      image: gcr.io/netflix-ml/model-evaluation:latest
      command: ["python", "evaluate.py"]</code></pre>
                    </div>
                </div>

                <!-- Results -->
                <div class="card bg-secondary mb-4">
                    <div class="card-body">
                        <h3 class="card-title">üìà R√©sultats et Performance</h3>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="text-center">
                                    <h4 class="text-primary">92%</h4>
                                    <p>Pr√©cision recommandations</p>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="text-center">
                                    <h4 class="text-success">85ms</h4>
                                    <p>Latence moyenne</p>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="text-center">
                                    <h4 class="text-warning">50M+</h4>
                                    <p>Interactions trait√©es</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Back Button -->
                <div class="text-center">
                    <a href="../index.html" class="btn btn-primary btn-lg">
                        <i class="fas fa-arrow-left me-2"></i>Retour au Portfolio
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>
